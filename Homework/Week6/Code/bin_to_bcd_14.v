module bin_to_bcd_14 (
    input[13:0] b, //最大值为14'b11_1111_1111_1111=16383，数码管能显示的最大值为9999=14'b10_0111_0000_1111
    output reg[16:0] p //16383对应BCD码有17位，9999对应BCD码为16'b1001_1001_1001_1001，有14位 
);
    //在CSDN上查到的将二进制转换为8421码的一种既高效又节省资源的方法
    //博主称其为大4加3法，具体原理网上的各类博客都语焉不详，我个人不是很懂
    //只知道其大概利用的是如果某位大于4，×2后对应的8421码就必须进位，因此提前加3保证能正确产生进位信号
    //以下是具体实现代码

    reg[30:0] z; //将二进制存储在最低14位，然后通过循环左移，最终最高17位就是BCD码
    integer i;

    always@(*) begin
        for(i=0;i<=30;i=i+1) z[i]=0;    
        z[16:3]=b; //直接把b左移3位了
        repeat(11) //一共14位，所以要移位14次，前面已经移动了3次，所以这里再移位11次
        begin
            if(z[17:14]>4) //如果个位大于4
                z[17:14]=z[17:14]+3;
            else;
            if(z[21:18]>4) //如果十位大于4
                z[21:18]=z[21:18]+3;
            else;
            if(z[25:22]>4) //如果百位大于4
                z[25:22]=z[25:22]+3;
            else;
            if(z[29:26]>4) //如果千位大于4
                z[29:26]=z[29:26]+3;
            else;
            z[30:1]=z[29:0]; //左移一位
        end
        p=z[30:14]; 
    end
    
endmodule